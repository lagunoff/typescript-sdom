export type Prop<Model, T> = T|((m: Model) => T);
export type EventProp<Model, Action, Ev extends Event, Elem> = (e: WithTarget<Ev, Elem>, m: Model) => Action|void;
export type WithTarget<Ev extends Event, Target> = Omit<Ev, 'currentTarget'> & { currentTarget: Target };

export type Props<Model, Action, Elem = HTMLElement> = {
  className?: Prop<Model, string>;
  class?: Prop<Model, string>;
  style?: Prop<Model, string>;
  classList?: Record<string, boolean|((m: Model) => boolean)>
  title?: Prop<Model, string>;
  selected?: Prop<Model, boolean>;
  hidden?: Prop<Model, boolean>;
  value?: Prop<Model, string>;
  defaultValue?: Prop<Model, string>;
  accept?: Prop<Model, string>;
  acceptCharset?: Prop<Model, string>;
  action?: Prop<Model, string>;
  autocomplete?: Prop<Model, 'on'|'off'>;
  autosave?: Prop<Model, string>;
  disabled?: Prop<Model, boolean>;
  enctype?: Prop<Model, string>;
  formation?: Prop<Model, string>;
  list?: Prop<Model, string>;
  maxlength?: Prop<Model, string>;
  minlength?: Prop<Model, string>;
  method?: Prop<Model, string>;
  multiple?: Prop<Model, boolean>;
  novalidate?: Prop<Model, boolean>;
  pattern?: Prop<Model, string>;
  readonly?: Prop<Model, boolean>;
  required?: Prop<Model, boolean>;
  size?: Prop<Model, string>;
  for?: Prop<Model, string>;
  form?: Prop<Model, string>;
  max?: Prop<Model, string>;
  min?: Prop<Model, string>;
  step?: Prop<Model, string>;
  cols?: Prop<Model, string>;
  rows?: Prop<Model, string>;
  wrap?: Prop<Model, string>;
  target?: Prop<Model, string>;
  download?: Prop<Model, string>;
  poster?: Prop<Model, string>;
  downloadAs?: Prop<Model, string>;
  hreflang?: Prop<Model, string>;
  media?: Prop<Model, string>;
  ping?: Prop<Model, string>;
  rel?: Prop<Model, string>;
  ismap?: Prop<Model, string>;
  usemap?: Prop<Model, string>;
  shape?: Prop<Model, string>;
  coords?: Prop<Model, string>;
  src?: Prop<Model, string>;
  height?: Prop<Model, string>;
  width?: Prop<Model, string>;
  alt?: Prop<Model, string>;
  autoplay?: Prop<Model, string>;
  controls?: Prop<Model, boolean>;
  loop?: Prop<Model, boolean>;
  preload?: Prop<Model, string>;
  default?: Prop<Model, boolean>;
  kind?: Prop<Model, string>;
  srclang?: Prop<Model, string>;
  sandbox?: Prop<Model, string>;
  seamless?: Prop<Model, string>;
  srcdoc?: Prop<Model, string>;
  reversed?: Prop<Model, string>;
  start?: Prop<Model, string>;
  align?: Prop<Model, string>;
  colspan?: Prop<Model, string>;
  rowspan?: Prop<Model, string>;
  headers?: Prop<Model, string>;
  scope?: Prop<Model, string>;
  async?: Prop<Model, boolean>;
  charset?: Prop<Model, string>;
  content?: Prop<Model, string>;
  defer?: Prop<Model, string>;
  httpEquiv?: Prop<Model, string>;
  language?: Prop<Model, string>;
  scoped?: Prop<Model, string>;
  type?: Prop<Model, string>;
  name?: Prop<Model, string>;
  href?: Prop<Model, string>;
  id?: Prop<Model, string>;
  placeholder?: Prop<Model, string>;
  checked?: Prop<Model, boolean>;
  autofocus?: Prop<Model, boolean>;

  // Element events
  onabort?: EventProp<Model, Action, HTMLElementEventMap['abort'], Elem>;
  onanimationcancel?: EventProp<Model, Action, HTMLElementEventMap['animationcancel'], Elem>;
  onanimationend?: EventProp<Model, Action, HTMLElementEventMap['animationend'], Elem>;
  onanimationiteration?: EventProp<Model, Action, HTMLElementEventMap['animationiteration'], Elem>;
  onanimationstart?: EventProp<Model, Action, HTMLElementEventMap['animationstart'], Elem>;
  onauxclick?: EventProp<Model, Action, HTMLElementEventMap['auxclick'], Elem>;
  onblur?: EventProp<Model, Action, HTMLElementEventMap['blur'], Elem>;
  oncancel?: EventProp<Model, Action, HTMLElementEventMap['cancel'], Elem>;
  oncanplay?: EventProp<Model, Action, HTMLElementEventMap['canplay'], Elem>;
  oncanplaythrough?: EventProp<Model, Action, HTMLElementEventMap['canplaythrough'], Elem>;
  onchange?: EventProp<Model, Action, HTMLElementEventMap['change'], Elem>;
  onclick?: EventProp<Model, Action, HTMLElementEventMap['click'], Elem>;
  onclose?: EventProp<Model, Action, HTMLElementEventMap['close'], Elem>;
  oncontextmenu?: EventProp<Model, Action, HTMLElementEventMap['contextmenu'], Elem>;
  oncuechange?: EventProp<Model, Action, HTMLElementEventMap['cuechange'], Elem>;
  ondblclick?: EventProp<Model, Action, HTMLElementEventMap['dblclick'], Elem>;
  ondrag?: EventProp<Model, Action, HTMLElementEventMap['drag'], Elem>;
  ondragend?: EventProp<Model, Action, HTMLElementEventMap['dragend'], Elem>;
  ondragenter?: EventProp<Model, Action, HTMLElementEventMap['dragenter'], Elem>;
  ondragexit?: EventProp<Model, Action, HTMLElementEventMap['dragexit'], Elem>;
  ondragleave?: EventProp<Model, Action, HTMLElementEventMap['dragleave'], Elem>;
  ondragover?: EventProp<Model, Action, HTMLElementEventMap['dragover'], Elem>;
  ondragstart?: EventProp<Model, Action, HTMLElementEventMap['dragstart'], Elem>;
  ondrop?: EventProp<Model, Action, HTMLElementEventMap['drop'], Elem>;
  ondurationchange?: EventProp<Model, Action, HTMLElementEventMap['durationchange'], Elem>;
  onemptied?: EventProp<Model, Action, HTMLElementEventMap['emptied'], Elem>;
  onended?: EventProp<Model, Action, HTMLElementEventMap['ended'], Elem>;
  onerror?: EventProp<Model, Action, HTMLElementEventMap['error'], Elem>;
  onfocus?: EventProp<Model, Action, HTMLElementEventMap['focus'], Elem>;
  ongotpointercapture?: EventProp<Model, Action, HTMLElementEventMap['gotpointercapture'], Elem>;
  oninput?: EventProp<Model, Action, HTMLElementEventMap['input'], Elem>;
  oninvalid?: EventProp<Model, Action, HTMLElementEventMap['invalid'], Elem>;
  onkeydown?: EventProp<Model, Action, HTMLElementEventMap['keydown'], Elem>;
  onkeypress?: EventProp<Model, Action, HTMLElementEventMap['keypress'], Elem>;
  onkeyup?: EventProp<Model, Action, HTMLElementEventMap['keyup'], Elem>;
  onload?: EventProp<Model, Action, HTMLElementEventMap['load'], Elem>;
  onloadeddata?: EventProp<Model, Action, HTMLElementEventMap['loadeddata'], Elem>;
  onloadedmetadata?: EventProp<Model, Action, HTMLElementEventMap['loadedmetadata'], Elem>;
  onloadend?: EventProp<Model, Action, HTMLElementEventMap['loadend'], Elem>;
  onloadstart?: EventProp<Model, Action, HTMLElementEventMap['loadstart'], Elem>;
  onlostpointercapture?: EventProp<Model, Action, HTMLElementEventMap['lostpointercapture'], Elem>;
  onmousedown?: EventProp<Model, Action, HTMLElementEventMap['mousedown'], Elem>;
  onmouseenter?: EventProp<Model, Action, HTMLElementEventMap['mouseenter'], Elem>;
  onmouseleave?: EventProp<Model, Action, HTMLElementEventMap['mouseleave'], Elem>;
  onmousemove?: EventProp<Model, Action, HTMLElementEventMap['mousemove'], Elem>;
  onmouseout?: EventProp<Model, Action, HTMLElementEventMap['mouseout'], Elem>;
  onmouseover?: EventProp<Model, Action, HTMLElementEventMap['mouseover'], Elem>;
  onmouseup?: EventProp<Model, Action, HTMLElementEventMap['mouseup'], Elem>;
  onpause?: EventProp<Model, Action, HTMLElementEventMap['pause'], Elem>;
  onplay?: EventProp<Model, Action, HTMLElementEventMap['play'], Elem>;
  onplaying?: EventProp<Model, Action, HTMLElementEventMap['playing'], Elem>;
  onpointercancel?: EventProp<Model, Action, HTMLElementEventMap['pointercancel'], Elem>;
  onpointerdown?: EventProp<Model, Action, HTMLElementEventMap['pointerdown'], Elem>;
  onpointerenter?: EventProp<Model, Action, HTMLElementEventMap['pointerenter'], Elem>;
  onpointerleave?: EventProp<Model, Action, HTMLElementEventMap['pointerleave'], Elem>;
  onpointermove?: EventProp<Model, Action, HTMLElementEventMap['pointermove'], Elem>;
  onpointerout?: EventProp<Model, Action, HTMLElementEventMap['pointerout'], Elem>;
  onpointerover?: EventProp<Model, Action, HTMLElementEventMap['pointerover'], Elem>;
  onpointerup?: EventProp<Model, Action, HTMLElementEventMap['pointerup'], Elem>;
  onprogress?: EventProp<Model, Action, HTMLElementEventMap['progress'], Elem>;
  onratechange?: EventProp<Model, Action, HTMLElementEventMap['ratechange'], Elem>;
  onreset?: EventProp<Model, Action, HTMLElementEventMap['reset'], Elem>;
  onresize?: EventProp<Model, Action, HTMLElementEventMap['resize'], Elem>;
  onscroll?: EventProp<Model, Action, HTMLElementEventMap['scroll'], Elem>;
  onsecuritypolicyviolation?: EventProp<Model, Action, HTMLElementEventMap['securitypolicyviolation'], Elem>;
  onseeked?: EventProp<Model, Action, HTMLElementEventMap['seeked'], Elem>;
  onseeking?: EventProp<Model, Action, HTMLElementEventMap['seeking'], Elem>;
  onselect?: EventProp<Model, Action, HTMLElementEventMap['select'], Elem>;
  onstalled?: EventProp<Model, Action, HTMLElementEventMap['stalled'], Elem>;
  onsubmit?: EventProp<Model, Action, HTMLElementEventMap['submit'], Elem>;
  onsuspend?: EventProp<Model, Action, HTMLElementEventMap['suspend'], Elem>;
  ontimeupdate?: EventProp<Model, Action, HTMLElementEventMap['timeupdate'], Elem>;
  ontoggle?: EventProp<Model, Action, HTMLElementEventMap['toggle'], Elem>;
  ontouchcancel?: EventProp<Model, Action, HTMLElementEventMap['touchcancel'], Elem>;
  ontouchend?: EventProp<Model, Action, HTMLElementEventMap['touchend'], Elem>;
  ontouchmove?: EventProp<Model, Action, HTMLElementEventMap['touchmove'], Elem>;
  ontouchstart?: EventProp<Model, Action, HTMLElementEventMap['touchstart'], Elem>;
  ontransitioncancel?: EventProp<Model, Action, HTMLElementEventMap['transitioncancel'], Elem>;
  ontransitionend?: EventProp<Model, Action, HTMLElementEventMap['transitionend'], Elem>;
  ontransitionrun?: EventProp<Model, Action, HTMLElementEventMap['transitionrun'], Elem>;
  ontransitionstart?: EventProp<Model, Action, HTMLElementEventMap['transitionstart'], Elem>;
  onvolumechange?: EventProp<Model, Action, HTMLElementEventMap['volumechange'], Elem>;
  onwaiting?: EventProp<Model, Action, HTMLElementEventMap['waiting'], Elem>;
  onwheel?: EventProp<Model, Action, HTMLElementEventMap['wheel'], Elem>;
};

export const attributes = {
  for: '', class: '',
};

export type Omit<T, U extends keyof T> = { [K in Exclude<keyof T, U>]: T[K] };
